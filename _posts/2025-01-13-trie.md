---
title: "什么是Trie字典树(前缀树)"
subtitle: "trie树原理及其应用"
author: "painter"
date: 2025-01-13 16:14:00

tag:
    - Python
    - Trie
    - 数据结构
---


# 什么是Trie？

### **Trie树介绍**

**Trie树**（也称为字典树或前缀树）是一种用于高效存储和检索字符串集合的树形数据结构。它特别适合处理具有相同前缀的字符串集合，常用于实现快速的字符串搜索、自动补全、拼写检查等功能。

---

### **Trie的特点**

1. **节点表示字符**：
   - 每个节点表示一个字符。
   - 从根节点到某个节点的路径表示一个字符串的前缀。

2. **字符串分层存储**：
   - 所有具有相同前缀的字符串共享一个公共的路径节点。

3. **插入和搜索高效**：
   - 插入和搜索的时间复杂度与字符串长度成正比，即 \( O(L) \)，其中 \( L \) 是字符串的长度。

4. **终止标记**：
   - 节点通常带有一个布尔值或标记，用于表示是否是某个字符串的结束。

---

### **Trie的结构**

- **根节点 (Root)**：Trie树的顶端，通常为空。
- **边 (Edge)**：从一个节点到另一个节点的连接，表示字符。
- **子节点 (Children)**：每个节点可能有多个子节点，每个子节点代表一个字符。
- **结束标记 (End of Word)**：用于区分是否存在一个完整的字符串。

例如，插入字符串集合 `["cat", "car", "bat"]` 后的Trie树结构如下：
```
      (root)
      /   \
     c     b
    / \     \
   a   a     a
  /     \     \
 t       r     t
```
- `"cat"` 路径：`root -> c -> a -> t`
- `"car"` 路径：`root -> c -> a -> r`
- `"bat"` 路径：`root -> b -> a -> t`

---

### **Trie的操作**

#### **1. 插入 (Insert)**

插入字符串到Trie树时，从根节点开始：
1. 遍历字符串的每个字符。
2. 如果字符对应的子节点不存在，则创建新节点。
3. 如果字符是字符串的最后一个字符，标记为结束节点。

**代码示例**：
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True
```

---

#### **2. 搜索 (Search)**

查找一个字符串是否存在：
1. 从根节点开始遍历字符串的每个字符。
2. 如果某个字符不存在于当前节点的子节点中，则字符串不存在。
3. 遍历结束后，检查是否到达字符串的结束标记。

**代码示例**：
```python
    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word
```

---

#### **3. 前缀检查 (StartsWith)**

检查Trie树中是否存在以某个前缀开头的字符串：
1. 遍历字符串的每个字符。
2. 如果某个字符不存在于当前节点的子节点中，则前缀不存在。
3. 如果遍历结束，说明存在该前缀。

**代码示例**：
```python
    def starts_with(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True
```

---

### **Trie的应用**

1. **字符串搜索**：
   - 判断字符串是否存在，例如拼写检查。

2. **前缀匹配**：
   - 查找具有某个前缀的所有单词，例如自动补全功能。

3. **单词统计**：
   - 统计具有某个前缀的单词数量。

4. **字典存储**：
   - 高效存储大规模字符串集合，例如URL或配置文件。

---

### **Trie的优缺点**

#### **优点**：
1. **快速搜索**：字符串搜索和插入的时间复杂度为 \( O(L) \)。
2. **存储高效**：共享前缀的字符串只存储一次，节省空间。

#### **缺点**：
1. **空间消耗大**：如果字符串没有共享前缀，每个字符都需要单独存储。
2. **实现复杂性**：相较于简单的哈希表，Trie的实现更复杂。

---

### **总结**

| 操作         | 时间复杂度 |
|--------------|------------|
| 插入字符串   | \( O(L) \) |
| 搜索字符串   | \( O(L) \) |
| 前缀搜索     | \( O(L) \) |

- **Trie树适合场景**：
  - 需要快速前缀匹配。
  - 需要处理海量字符串集合。
  - 不希望受到字符串长度或哈希冲突的限制。

---

```
class PrefixTree:

    def __init__(self):
        self.children = [None] * 26
        self.wordEnd = False
        

    def insert(self, word: str) -> None:
        node = self
        for c in word:
            i = ord(c) - ord('a')
            if node.children[i] == None:
                node.children[i] = PrefixTree()
            
            node = node.children[i]
        node.wordEnd = True

    def search(self, word: str) -> bool:
        node = self
        for c in word:
            i = ord(c) - ord('a')
            if node.children[i] == None:
                return False
            node = node.children[i]
        if node.wordEnd:
            return True
        return False
        

    def startsWith(self, prefix: str) -> bool:
        node = self
        for c in prefix:
            i = ord(c) - ord('a')
            if node.children[i] == None:
                return False
            node = node.children[i]
        return True
```